{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lanousyuan","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java集合类（容器)","slug":"Java集合类（容器)","date":"2019-04-14T13:35:48.000Z","updated":"2019-04-15T09:14:43.055Z","comments":true,"path":"2019/04/14/Java集合类（容器)/","link":"","permalink":"http://yoursite.com/2019/04/14/Java集合类（容器)/","excerpt":"Collections集合类集合存放在java.util包中，分为set(集）、list(列表）和map(映射)三类详细地分享了集合类的使用。","text":"Collections集合类集合存放在java.util包中，分为set(集）、list(列表）和map(映射)三类详细地分享了集合类的使用。 ListList中顺序与存放顺序一致且允许重复，主要实现类有ArrayList、LinkedList、Vector。 ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 List&lt;String&gt; c=new ArrayList&lt;&gt;(); System.out.println(c.size()); //返回当前大小 System.out.println(c.isEmpty()); //判断是否为空 c.add(\"aaa\"); //增加元素 c.add(\"bbb\"); System.out.println(c); System.out.println(c.size()); System.out.println(c.contains(\"aaa\")); //判断是否包含元素 Object obj=c.toArray(); //转换为一个Object对象 System.out.println(obj); c.remove(\"bbb\"); //移除元素 System.out.println(c); c.clear(); //清空元素 System.out.println(c.size()); List&lt;String&gt; list03=new ArrayList&lt;&gt;(); list03.add(\"A\"); list03.add(\"B\"); list03.add(\"C\"); list03.add(\"D\"); System.out.println(list03); list03.add(2,\"zy\"); //在指定索引位置处插入元素 System.out.println(list03); list03.remove(2); //移除指定索引处的元素 System.out.println(list03); list03.set(2, \"zy\"); //替换指定索引处的元素 System.out.println(list03);//输出结果如下： 0true[aaa, bbb]2true[Ljava.lang.Object;@3b192d32[aaa]0[A, B, C, D][A, B, zy, C, D][A, B, C, D][A, B, zy, D] ArrayList类似于数组，使用了顺序存储结构。 ArrayList由于使用顺序存储结构，所以当容量告急时需进行扩容，而ArrayList的扩容通过数组拷贝arraycopy实现。 如顺序存储结构一样，ArrayList在执行插入或删除操作时需要遍历该索引之后的所有元素，执行效率不高。 LinkedList LinkedList为链式存储结构，在使用时无需考虑空间问题，一个节点由前指针、数据域、后指针构成。 123Node previous; //上一个节点Node next; //下一个节点Object element; //数据元素 LinkedList在执行插入或删除操作时，只需要改变指针的指向，无需遍历整个集合。但是在查找时，需要从头指针开始进行遍历，因此查询效率低，插入或删除效率高。 Vector 与ArrayList相比提供了一个线程安全的集合，但是在效率上有了牺牲，大部分方法与其类似。 MapMap用于存放键值对（key–value）,其中key不可重复，value可以存放Object类的任意对象。主要实现类有HashMap、TreeMap。 HashMap HashMap线程不安全，效率高，允许key或value为null，HashTable线程安全，效率低，不允许key或value为null。 12345678910111213141516171819202122232425262728293031323334Map&lt;Integer,String&gt; m1=new HashMap&lt;&gt;();m1.put(1, \"one\"); //存放键值对m1.put(2, \"two\");m1.put(3, \"three\");System.out.println(m1.get(1)); //获得指定key对应的值System.out.println(m1.size()); //获取集合的大小System.out.println(m1.isEmpty()); //判断是否为空System.out.println(m1.containsKey(2)); //是否包含指定键System.out.println(m1.containsValue(\"four\")); //是否包含指定值Map&lt;Integer,String&gt; m2=new HashMap&lt;&gt;();m2.put(4, \"四\");m2.put(5, \"五\");m1.putAll(m2);System.out.println(m1);//键值Key不能重复，如有重复，新的会将老的覆盖m1.put(3, \"三\");System.out.println(m1);//value可以存放自定义类Employee e1=new Employee(1001,\"张三\",50000);Employee e2=new Employee(1002,\"李四\",10000);Employee e3=new Employee(1003,\"王五\",8000);Employee e4=new Employee(1004,\"小七\",6000);Employee e5=new Employee(1001,\"小六\",6000);Map&lt;Integer,Employee&gt; map=new HashMap&lt;&gt;();map.put(1001, e1);map.put(1002, e2);map.put(1003, e3);map.put(1004, e4);map.put(1001, e5);Employee emp=map.get(1001); HashMap中的结点格式如下： 1234int hash; //用于存放Hash值K key; //存放键V value; //存放值Node next; //下一个结点的指针 hash值是通过key对象的hashcode()经特定算法（如：与bucket array的长度按位与）计算出来的。等于在bucket array的每一个元素位置存入一个链表。 所以HashMap输出的对象顺序与存入时是不同的。 TreeMap TreeMap与HashMap最大的区别就是有无顺序，TreeMap中存放时会对对象进行排序。 此时可以通过实现Comparable接口是对象可以通过自比较进行我们想要的排序，只要重写compareTo()方法即可。 SetSet中没有顺序且不允许重复，实现类主要有HashSet、TreeSet HashSet底层通过HashMap实现，存入HashSet的值等于HashMap中的key值，所以其中的值没有顺序且不允许重复。 HashSet与TreeSet的区别类似于TreeMap与HashMap的区别。 Collections辅助类Collection是接口，Collections是工具类 123456789101112131415List&lt;String&gt; list =new ArrayList&lt;&gt;();for(int i=0;i&lt;10;i++) &#123; list.add(\"lanous\"+i);&#125;System.out.println(list);Collections.shuffle(list); //随机排列list中的元素System.out.println(list);Collections.reverse(list); //倒序排列System.out.println(list);Collections.sort(list); //按照递增顺序排序，自定义的类使用Comparable接口System.out.println(list);System.out.println(Collections.binarySearch(list, \"lanous3\"));//二分法查找 Iterator迭代器的使用（遍历容器内的元素） List 12345678910111213List&lt;String&gt; list=new ArrayList&lt;&gt;();list.add(\"aa\");list.add(\"bb\");list.add(\"cc\");//使用Iterator遍历Listfor(Iterator&lt;String&gt; iter=list.iterator();iter.hasNext();) &#123; String temp=iter.next(); System.out.println(temp);&#125;System.out.println();for(Object temp:list) &#123; System.out.println(temp);&#125; 增强for循环输出与迭代器遍历输出比较，结果一样。 Map 123456789101112131415161718192021Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();map.put(1, \"a\");map.put(2, \"b\");map.put(3, \"c\");//使用Iterator遍历Map（一）Set&lt;Entry&lt;Integer,String&gt;&gt; ss =map.entrySet();for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter=ss.iterator();iter.hasNext();) &#123; Entry&lt;Integer,String&gt; temp=iter.next(); System.out.println(temp.getKey()+\"---\"+temp.getValue());&#125;System.out.println();//遍历Map（二）Set&lt;Integer&gt; keySet=map.keySet();for(Iterator&lt;Integer&gt; iter=keySet.iterator();iter.hasNext();) &#123; Integer key=iter.next(); System.out.println(key+\"---\"+map.get(key));&#125; 遍历Map有两种方式： （一）通过Map.entrySet每一次遍历返回一个key/value键值对的对象，可以一次遍历Map中的元素。 （二）通过Map.keySet遍历key对象，然后通过key进行取值。此方法相较于前者更加灵活，可以根据需要取得指定key相对应的值。 Map.entrySet迭代器会生成EntryIterator,其返回的实例是一个包含key/value键值对的对象。而keySet中迭代器返回的只是key对象，还需要到map中二次取值。 Set 12345678910Set&lt;String&gt; set=new HashSet&lt;&gt;();set.add(\"aa\");set.add(\"bb\");set.add(\"cc\");//使用Iterator遍历Setfor(Iterator&lt;String&gt; iter=set.iterator();iter.hasNext();) &#123; String temp=iter.next(); System.out.println(temp);&#125; 使用方法与List相差无几。","categories":[],"tags":[]},{"title":"Java知识点总结（三）","slug":"Java知识点总结（三）","date":"2019-04-05T13:47:52.000Z","updated":"2019-04-15T09:14:18.469Z","comments":true,"path":"2019/04/05/Java知识点总结（三）/","link":"","permalink":"http://yoursite.com/2019/04/05/Java知识点总结（三）/","excerpt":"Java知识点总结（三）","text":"Java知识点总结（三） 时间对象和字符串之间的互相转换 把时间对象按照指定格式转换成相应的字符串 123DateFormat df=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");String str=df.format(new Date(4000000));System.out.println(str); 此时输出就是按照自己用“y,M,d,h,s”等字母所指定的时间格式 把字符串按照相应的格式转成相应的时间对象 123DateFormat df2=new SimpleDateFormat(\"yyyy年MM月dd日 hh时mm分ss秒\");Date date=df2.parse(\"1983年06月03日 21时34分33秒\");System.out.println(date); 此时输出结果为Fri Jun 03 21:34:33 GMT+08:00 1983，通过parse()方法可以按指定格式将输入的字符串解析为时间对象。 随机数Random类1234567891011121314151617181920212223242526public class TestRandom &#123; public static void main(String[] args) &#123; Random rand=new Random(); //随机生成[0,1)之间的double类型的数据 System.out.println(rand.nextDouble()); //随机生成int类型允许范围之内的整形数据 System.out.println(rand.nextInt()); //随机生成[0,1)之间的float类型的数据 System.out.println(rand.nextFloat()); //随机生成false或者true System.out.println(rand.nextBoolean()); //随机生成[0,10)之间的int类型的数据 System.out.println(rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据 System.out.println(20+rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂） System.out.println(20+(int)(rand.nextDouble()*10)); &#125;&#125; 可变字符序列StringBuilder123456789101112131415161718192021public class TestStringBuilder2 &#123; public static void main(String[] args) &#123; StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;26;i++) &#123; sb.append((char)('a'+i)); &#125; System.out.println(sb); sb.reverse();//倒序 System.out.println(sb); sb.setCharAt(3, '啦'); System.out.println(sb); sb.insert(0, '哦').insert(6,'嗯').insert(10, '啊');//链式调用。核心就是该方法调用了return this,把自己返回 System.out.println(sb); sb.delete(20,23); System.out.println(sb); &#125;&#125; append()方法可以在其中添加元素。reverse()方法实现倒叙功能。setCharAt()可以设置指定位置的元素。insert()方法可以通过链式调用实现连续插入。delete()用法类似于insert()。","categories":[],"tags":[]},{"title":"Java知识点总结（二）","slug":"Java知识点总结（二）","date":"2019-04-04T13:29:18.000Z","updated":"2019-04-15T09:14:38.833Z","comments":true,"path":"2019/04/04/Java知识点总结（二）/","link":"","permalink":"http://yoursite.com/2019/04/04/Java知识点总结（二）/","excerpt":"Java知识点总结（二）","text":"Java知识点总结（二） 数组拷贝 System类提供了arraycopy()方法实现数组的拷贝，JDK1.8中源码如下： 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 其中src为拷贝源数组，srcPos为源数组中要拷贝的第一个数据的索引下标，dest为目标数组，destPos为目标数组中拷贝的第一个位置下标，length为拷贝的长度。 arraycopy()可以实现删除数组中指定索引位置的元素，具体实现如下： 1234567public static String[] removeEle(String[] s,int index) &#123; System.arraycopy(s,index+1, s, index, s.length-index-1); s[s.length-1]=null; return s;&#125; 实际上就是数组的自我拷贝，将要删除的后面一位元素开始所有元素往前拷贝一格，就可以覆盖掉要删除的元素，然后将null赋值给数组的最后一个位置。 arraycopy()还可以实现数组的扩容。当一个数组空间不足时，可以通过数组扩容来实现加大空间，实现如下： 1234567public static String[] extendRange(String[] s1) &#123; String[] s2=new String[s1.length+10]; System.arraycopy(s1,0,s2,0,s1.length);//将S1中所有的元素拷贝到了S2 return s2; &#125; 实际就是定义一个更大的数组，然后将原数组的所有值从索引0位置开始拷贝到新数组中，然后返回新的数组，从而实现数组的扩容。 数组工具类的使用1234567891011121314public class TestArrays &#123; public static void main(String[] args) &#123; int[] a= &#123;11,33,226,77,44,276,20&#125;; System.out.println(a); System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//排序 System.out.println(Arrays.toString(a)); System.out.println(Arrays.binarySearch(a, 77));//查找指定元素 System.out.println(Arrays.binarySearch(a, -77)); &#125;&#125; 定义数组时，赋值给a 的实际是一个地址指针，当直接打印a时，输出的时一个地址。想要输出数组中的每个元素，需要使用Array类提供的toString()方法，源码如下： 12345678910111213141516public static String toString(int[] a) &#123; if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); &#125;&#125; 通过StringBuilder类中的append()方法循坏添加所有元素，然后返回。 sort()方法实现升序排序。 binarySearch方法查找并返回指定的元素，当元素不存在时，返回-1。 通过二维数组实现存储表格数据12345678Object[] emp1= &#123;1001,\"张三\",23,\"学生\",\"1995-12-27\"&#125;;Object[] emp2= &#123;1002,\"李四\",24,\"学2生\",\"1993-10-17\"&#125;;Object[] emp3= &#123;1003,\"王五\",25,\"学3生\",\"1994-10-07\"&#125;;Object[][] tableData= new Object[3][];tableData[0]=emp1;tableData[1]=emp2;tableData[2]=emp3; 冒泡排序算法12345678910111213141516171819202122232425262728public class TestBubbleSort &#123; public static void main(String[] args) &#123; int temp; int[] a= &#123;2873,23,54,24,9838,563,30487,2653&#125;; for(int i=0;i&lt;a.length-1;i++) &#123; boolean flag=true; for(int j=0;j&lt;a.length-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; flag=false; &#125; System.out.println(Arrays.toString(a)); &#125; if(flag) &#123; System.out.println(\"循环结束\"); break; &#125; System.out.println(\"###################\"); &#125; &#125;&#125; 加入一个布尔类型的变量，当一整行数据全部循环一次但没有发生交换时，说明排序已经结束，就跳出循环，不再进行之后无用的循环，提高了循环效率。 二分法查找算法123456789101112131415161718public static int BinarySearch(int[] arr,int value) &#123; //二分法查找 int low=0; int high=arr.length-1; while(low&lt;=high) &#123; int mid = (low+high)/2; if(value==arr[mid]) &#123; return mid; &#125; if(value&gt;arr[mid]) &#123; low=mid+1; &#125; if(value&lt;arr[mid]) &#123; high=mid-1; &#125; &#125; return -1;&#125; 使用二分法查找必须确保数组已经排好顺序。 当一个顺序数组输入时，每次从中间开始进行比较并舍弃掉数组不在的那一半，再次重复，直到查到结果为止。","categories":[],"tags":[]},{"title":"Java知识点总结（一）","slug":"Java知识点总结（一）","date":"2019-03-31T14:14:59.000Z","updated":"2019-04-15T09:14:10.651Z","comments":true,"path":"2019/03/31/Java知识点总结（一）/","link":"","permalink":"http://yoursite.com/2019/03/31/Java知识点总结（一）/","excerpt":"Java知识点总结（一）","text":"Java知识点总结（一） abstract抽象类 抽象类为子类提供统一的、规范的模板,子类必须实现相关的抽象方法。 123456public abstract class Animal &#123; //没有实现。子类必须实现 abstract public void shout(); &#125; 如上抽象类中的抽象方法没有实现，继承自此抽象类的子类必须实现shout()方法，如下给出的语句块，若不实现会编译报错。 123456789class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println(\"汪汪汪\"); &#125; &#125; 接口及其实现类 接口使用interface关键字定义，接口中只能定义常量且接口中的方法皆为抽象方法。接口的实现通过implements关键字实现。如下的MyClass类中必须实现test01()方法，并且可以在方法中直接使用MAX_AGE常量。 123456789101112131415161718public interface TestInterface &#123; int MAX_AGE=100;//接口中只能定义常量 void test01();//方法只能抽象&#125;class MyClass implements TestIterface&#123; @Override public void test01() &#123; System.out.println(\"llll\"); System.out.println(MAX_AGE); &#125; &#125; 接口可以多继承而普通类无法继承多个类 12345678910111213141516171819202122232425interface A&#123; void test1();&#125;interface B&#123; void test2();&#125;//接口可以多继承，接口C继承接口A和Binterface C extends A,B&#123; void test3();&#125;class T implements C &#123; @Override public void test1() &#123; &#125; @Override public void test2() &#123; &#125; @Override public void test3() &#123; &#125;&#125; String字符串类及基本用法 String初始化有两种方法，“+”可以作为字符串连接符使用 1234567891011121314String str=\"asd\";String str2=new String(\"asd\");String str3=\"abc\"+\"sjdh\";String str4=\"18\"+19;//当加法一边是字符串类型时，加法作为字符串连接符，输出“1819”System.out.println(str4);System.out.println(\"###########\");String str10=\"zy\";String str11=\"zy\";String str12=new String(\"zy\");System.out.println(str10==str11);System.out.println(str11==str12); //str11和str12不是同一个对象 如上语句块中str11和str12虽然定义了相同的字符串，但是str11==str12的运算结果却是false，因为两种方法底层实现不同，进行==运算时比较的是不同的内存地址。 所以通常比较字符串时，使用equals 1System.out.println(str12.equals(str11));//此时的输出是true，比较的是一个个字符 以下提供了String类的一些常用方法： 123456789101112131415161718192021222324252627282930313233343536373839String s1=\"core Java\";String s2=\"Core Java\";System.out.println(s1.charAt(3));//提取下标为3处的字符System.out.println(s2.length());//返回字符串长度System.out.println(s1.equals(s2));//比较两个字符串是否相等System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串是否相等（忽略大小写）System.out.println(s1.indexOf(\"Java\"));//s1中是否包含Java,返回Java的第一个位置下标System.out.println(s1.indexOf(\"apple\"));//s1中是否包含apple,不包含时返回-1String s=s1.replace(' ','&amp;');//将s1中的空格替换成&amp;，s1本身没变System.out.println(\"result is:\"+s);String ss=\"\";String ss1=\"How are you?\";System.out.println(ss1.startsWith(\"How\"));//判断是否以How开头System.out.println(ss1.endsWith(\"you\"));//判断是否以you结尾ss=ss1.substring(4);//提取子字符串：从下标为4的开始到字符串结尾结束System.out.println(ss);ss=ss1.substring(4, 7);//提取字符串：下标[4，7）System.out.println(ss);ss=ss1.toLowerCase();//转小写System.out.println(ss);ss=ss1.toUpperCase();//转大写System.out.println(ss);String ss2=\" How old are you? \";ss=ss2.trim();//去除字符串首位的空格，中间的不去除System.out.println(ss);System.out.println(ss2);","categories":[],"tags":[]},{"title":"飞机小游戏总结","slug":"飞机小游戏总结","date":"2019-03-28T05:05:54.000Z","updated":"2019-04-15T09:13:32.670Z","comments":true,"path":"2019/03/28/飞机小游戏总结/","link":"","permalink":"http://yoursite.com/2019/03/28/飞机小游戏总结/","excerpt":"小飞机游戏使用最基础知识编写，上传仅用于学习交流（复习知识）","text":"小飞机游戏使用最基础知识编写，上传仅用于学习交流（复习知识） 实现效果如下： 新游戏： 游戏结束： 详细代码见GitHub 重要知识点 创建getImage方法用于输入路径以返回图片对象,其中所使用的IO流知识有待进一步学习。 1234567891011 //GameUtil类的公共方法实现所有图片的读取public static Image getImage(String path) &#123; BufferedImage bi=null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; return bi;&#125; 重写键盘监听的内部类方法对按键的按下和松开监听实现对飞机的控制 1234567891011121314//键盘监听的内部类class KeyMonitor extends KeyAdapter&#123; @Override public void keyPressed(KeyEvent e) &#123; super.keyPressed(e); p.addDirection(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; super.keyReleased(e); p.minusDirection(e); &#125; 实现此类需导入如下Java包 123import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent; 重写方法实现窗口的更新 1234567891011121314151617class PaintThread extends Thread&#123; @Override public void run() &#123; super.run(); while(true) &#123; repaint();//重画 try &#123; Thread.sleep(40);//1s画25次 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后记 个人选了几个觉得感触最深的片段，详细代码点在里。 仅作为Java初学者的见解,小项目为本人参照教程手打。 一个在Java路上越走越远的咸鱼","categories":[],"tags":[]},{"title":"测试第一篇博客文章","slug":"测试第一篇博客文章","date":"2019-03-15T08:45:00.000Z","updated":"2019-03-15T14:27:04.005Z","comments":true,"path":"2019/03/15/测试第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/03/15/测试第一篇博客文章/","excerpt":"","text":"第一章内容 第二章内容 参考文献啦啦啦啦啦","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T08:41:06.794Z","updated":"2019-03-15T08:41:06.794Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}