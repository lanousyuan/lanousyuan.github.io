{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lanousyuan","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java知识点总结（二）","slug":"Java知识点总结（二）","date":"2019-04-04T13:29:18.000Z","updated":"2019-04-05T06:21:48.973Z","comments":true,"path":"2019/04/04/Java知识点总结（二）/","link":"","permalink":"http://yoursite.com/2019/04/04/Java知识点总结（二）/","excerpt":"","text":"Java知识点总结数组拷贝 System类提供了arraycopy()方法实现数组的拷贝，JDK1.8中源码如下： 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 其中src为拷贝源数组，srcPos为源数组中要拷贝的第一个数据的索引下标，dest为目标数组，destPos为目标数组中拷贝的第一个位置下标，length为拷贝的长度。 arraycopy()可以实现删除数组中指定索引位置的元素，具体实现如下： 1234567public static String[] removeEle(String[] s,int index) &#123; System.arraycopy(s,index+1, s, index, s.length-index-1); s[s.length-1]=null; return s;&#125; 实际上就是数组的自我拷贝，将要删除的后面一位元素开始所有元素往前拷贝一格，就可以覆盖掉要删除的元素，然后将null赋值给数组的最后一个位置。 arraycopy()还可以实现数组的扩容。当一个数组空间不足时，可以通过数组扩容来实现加大空间，实现如下： 1234567public static String[] extendRange(String[] s1) &#123; String[] s2=new String[s1.length+10]; System.arraycopy(s1,0,s2,0,s1.length);//将S1中所有的元素拷贝到了S2 return s2; &#125; 实际就是定义一个更大的数组，然后将原数组的所有值从索引0位置开始拷贝到新数组中，然后返回新的数组，从而实现数组的扩容。 数组工具类的使用1234567891011121314public class TestArrays &#123; public static void main(String[] args) &#123; int[] a= &#123;11,33,226,77,44,276,20&#125;; System.out.println(a); System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//排序 System.out.println(Arrays.toString(a)); System.out.println(Arrays.binarySearch(a, 77));//查找指定元素 System.out.println(Arrays.binarySearch(a, -77)); &#125;&#125; 定义数组时，赋值给a 的实际是一个地址指针，当直接打印a时，输出的时一个地址。想要输出数组中的每个元素，需要使用Array类提供的toString()方法，源码如下： 12345678910111213141516public static String toString(int[] a) &#123; if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); &#125;&#125; 通过StringBuilder类中的append()方法循坏添加所有元素，然后返回。 sort()方法实现升序排序。 binarySearch方法查找并返回指定的元素，当元素不存在时，返回-1。 通过二维数组实现存储表格数据12345678Object[] emp1= &#123;1001,\"张三\",23,\"学生\",\"1995-12-27\"&#125;;Object[] emp2= &#123;1002,\"李四\",24,\"学2生\",\"1993-10-17\"&#125;;Object[] emp3= &#123;1003,\"王五\",25,\"学3生\",\"1994-10-07\"&#125;;Object[][] tableData= new Object[3][];tableData[0]=emp1;tableData[1]=emp2;tableData[2]=emp3; 冒泡排序算法12345678910111213141516171819202122232425262728public class TestBubbleSort &#123; public static void main(String[] args) &#123; int temp; int[] a= &#123;2873,23,54,24,9838,563,30487,2653&#125;; for(int i=0;i&lt;a.length-1;i++) &#123; boolean flag=true; for(int j=0;j&lt;a.length-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; flag=false; &#125; System.out.println(Arrays.toString(a)); &#125; if(flag) &#123; System.out.println(\"循环结束\"); break; &#125; System.out.println(\"###################\"); &#125; &#125;&#125; 加入一个布尔类型的变量，当一整行数据全部循环一次但没有发生交换时，说明排序已经结束，就跳出循环，不再进行之后无用的循环，提高了循环效率。 二分法查找算法123456789101112131415161718public static int BinarySearch(int[] arr,int value) &#123; //二分法查找 int low=0; int high=arr.length-1; while(low&lt;=high) &#123; int mid = (low+high)/2; if(value==arr[mid]) &#123; return mid; &#125; if(value&gt;arr[mid]) &#123; low=mid+1; &#125; if(value&lt;arr[mid]) &#123; high=mid-1; &#125; &#125; return -1;&#125; 使用二分法查找必须确保数组已经排好顺序。 当一个顺序数组输入时，每次从中间开始进行比较并舍弃掉数组不在的那一半，再次重复，直到查到结果为止。","categories":[],"tags":[]},{"title":"Java知识点总结（一）","slug":"Java知识点总结（一）","date":"2019-03-31T14:14:59.000Z","updated":"2019-03-31T15:07:36.891Z","comments":true,"path":"2019/03/31/Java知识点总结（一）/","link":"","permalink":"http://yoursite.com/2019/03/31/Java知识点总结（一）/","excerpt":"","text":"Java知识点总结（一）abstract抽象类 抽象类为子类提供统一的、规范的模板,子类必须实现相关的抽象方法。 123456public abstract class Animal &#123; //没有实现。子类必须实现 abstract public void shout(); &#125; 如上抽象类中的抽象方法没有实现，继承自此抽象类的子类必须实现shout()方法，如下给出的语句块，若不实现会编译报错。 123456789class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println(\"汪汪汪\"); &#125; &#125; 接口及其实现类 接口使用interface关键字定义，接口中只能定义常量且接口中的方法皆为抽象方法。接口的实现通过implements关键字实现。如下的MyClass类中必须实现test01()方法，并且可以在方法中直接使用MAX_AGE常量。 123456789101112131415161718public interface TestInterface &#123; int MAX_AGE=100;//接口中只能定义常量 void test01();//方法只能抽象&#125;class MyClass implements TestIterface&#123; @Override public void test01() &#123; System.out.println(\"llll\"); System.out.println(MAX_AGE); &#125; &#125; 接口可以多继承而普通类无法继承多个类 12345678910111213141516171819202122232425interface A&#123; void test1();&#125;interface B&#123; void test2();&#125;//接口可以多继承，接口C继承接口A和Binterface C extends A,B&#123; void test3();&#125;class T implements C &#123; @Override public void test1() &#123; &#125; @Override public void test2() &#123; &#125; @Override public void test3() &#123; &#125;&#125; String字符串类及基本用法 String初始化有两种方法，“+”可以作为字符串连接符使用 1234567891011121314String str=\"asd\";String str2=new String(\"asd\");String str3=\"abc\"+\"sjdh\";String str4=\"18\"+19;//当加法一边是字符串类型时，加法作为字符串连接符，输出“1819”System.out.println(str4);System.out.println(\"###########\");String str10=\"zy\";String str11=\"zy\";String str12=new String(\"zy\");System.out.println(str10==str11);System.out.println(str11==str12); //str11和str12不是同一个对象 如上语句块中str11和str12虽然定义了相同的字符串，但是str11==str12的运算结果却是false，因为两种方法底层实现不同，进行==运算时比较的是不同的内存地址。 所以通常比较字符串时，使用equals 1System.out.println(str12.equals(str11));//此时的输出是true，比较的是一个个字符 以下提供了String类的一些常用方法： 123456789101112131415161718192021222324252627282930313233343536373839String s1=\"core Java\";String s2=\"Core Java\";System.out.println(s1.charAt(3));//提取下标为3处的字符System.out.println(s2.length());//返回字符串长度System.out.println(s1.equals(s2));//比较两个字符串是否相等System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串是否相等（忽略大小写）System.out.println(s1.indexOf(\"Java\"));//s1中是否包含Java,返回Java的第一个位置下标System.out.println(s1.indexOf(\"apple\"));//s1中是否包含apple,不包含时返回-1String s=s1.replace(' ','&amp;');//将s1中的空格替换成&amp;，s1本身没变System.out.println(\"result is:\"+s);String ss=\"\";String ss1=\"How are you?\";System.out.println(ss1.startsWith(\"How\"));//判断是否以How开头System.out.println(ss1.endsWith(\"you\"));//判断是否以you结尾ss=ss1.substring(4);//提取子字符串：从下标为4的开始到字符串结尾结束System.out.println(ss);ss=ss1.substring(4, 7);//提取字符串：下标[4，7）System.out.println(ss);ss=ss1.toLowerCase();//转小写System.out.println(ss);ss=ss1.toUpperCase();//转大写System.out.println(ss);String ss2=\" How old are you? \";ss=ss2.trim();//去除字符串首位的空格，中间的不去除System.out.println(ss);System.out.println(ss2);","categories":[],"tags":[]},{"title":"飞机小游戏总结","slug":"飞机小游戏总结","date":"2019-03-28T05:05:54.000Z","updated":"2019-03-29T04:43:25.236Z","comments":true,"path":"2019/03/28/飞机小游戏总结/","link":"","permalink":"http://yoursite.com/2019/03/28/飞机小游戏总结/","excerpt":"","text":"小飞机游戏使用最基础知识编写，上传仅用于学习交流（复习知识）实现效果如下： 新游戏： 游戏结束： 详细代码见GitHub 重要知识点 创建getImage方法用于输入路径以返回图片对象,其中所使用的IO流知识有待进一步学习。 1234567891011 //GameUtil类的公共方法实现所有图片的读取public static Image getImage(String path) &#123; BufferedImage bi=null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; return bi;&#125; 重写键盘监听的内部类方法对按键的按下和松开监听实现对飞机的控制 1234567891011121314//键盘监听的内部类class KeyMonitor extends KeyAdapter&#123; @Override public void keyPressed(KeyEvent e) &#123; super.keyPressed(e); p.addDirection(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; super.keyReleased(e); p.minusDirection(e); &#125; 实现此类需导入如下Java包 123import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent; 重写方法实现窗口的更新 1234567891011121314151617class PaintThread extends Thread&#123; @Override public void run() &#123; super.run(); while(true) &#123; repaint();//重画 try &#123; Thread.sleep(40);//1s画25次 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后记 个人选了几个觉得感触最深的片段，详细代码点在里。 仅作为Java初学者的见解,小项目为本人参照教程手打。 一个在Java路上越走越远的咸鱼","categories":[],"tags":[]},{"title":"测试第一篇博客文章","slug":"测试第一篇博客文章","date":"2019-03-15T08:45:00.000Z","updated":"2019-03-15T14:27:04.005Z","comments":true,"path":"2019/03/15/测试第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/03/15/测试第一篇博客文章/","excerpt":"","text":"第一章内容 第二章内容 参考文献啦啦啦啦啦","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T08:41:06.794Z","updated":"2019-03-15T08:41:06.794Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}