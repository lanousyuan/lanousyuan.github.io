{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lanousyuan","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java多线程","slug":"Java多线程","date":"2019-04-18T14:16:50.000Z","updated":"2019-04-19T05:44:29.717Z","comments":true,"path":"2019/04/18/Java多线程/","link":"","permalink":"http://yoursite.com/2019/04/18/Java多线程/","excerpt":"多线程线程是进程的子集，Java线程提供了高并发的基础，表示同时进行的操作。","text":"多线程线程是进程的子集，Java线程提供了高并发的基础，表示同时进行的操作。 线程的创建 继承Thread+重写run()方法。这种方法为类的继承，所以拥有单继承的局限性，不方便资源的共享。 12345678910111213141516171819202122public class ThreadTest extends Thread&#123; /** * 线程入口 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println(\"听歌\"); &#125; &#125; public static void main(String[] args) &#123; //启动线程 ThreadTest st=new ThreadTest(); st.start();//不保证立即运行 for(int i=0;i&lt;100;i++) &#123; System.out.println(\"学习\"); &#125; &#125;&#125; 实现Runnable接口+重写run()方法,启动时创建实现对象+Thread对象+start() 1new Thread(new StartRun()).start(); 此方法便于资源的共享，推荐使用。 实现Callable接口，重写call()方法。当父线程想要获取子线程的运行结果时使用. 此方法启动时较为复杂。 1234567891011121314//启动三个线程//创建执行服务ExecutorService ser=Executors.newFixedThreadPool(3);//提交执行Future&lt;Boolean&gt; re1=ser.submit(td1);Future&lt;Boolean&gt; re2=ser.submit(td2);Future&lt;Boolean&gt; re3=ser.submit(td3);//获取结果boolean r1=re1.get();boolean r2=re2.get();boolean r3=re3.get();System.out.println(r3);//关闭服务ser.shutdownNow(); JDK8中新增了lambda表达式，有了新的线程启动方法 1234567//JDK8简化lambda表达式new Thread(()-&gt; &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println(\"听歌\"); &#125; &#125;).start(); 当线程体中只有一句话时，还可以简化为 1new Thread(()-&gt;System.out.println(\"hello\")) .start(); 线程的5种状态：新生—就绪—运行—阻塞—死亡 线程同步 synchronized关键字，它可以用来锁定方法和语句块。对于synchronized的合理使用，会使一个程序在线程安全的情况下有很大的性能提升。 12345678910111213141516//线程安全，范围太大，效率低public void test1() &#123; //synchronized块 synchronized(this) &#123; if(ticketNums&lt;=0) &#123; flag=false; return ; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"---\"+ticketNums--); &#125;&#125; 123456789101112131415161718192021//尽可能锁定合理范围（不是指代码，考虑实际情况）//double checkingpublic void test4() &#123; if(ticketNums&lt;=0) &#123;//考虑没有票的情况 flag=false; return ; &#125; //synchronized块 synchronized(this) &#123; if(ticketNums&lt;=0) &#123;//考虑最后一张票 flag=false; return ; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"---\"+ticketNums--); &#125;&#125; 此处模拟了有网络延迟的抢票环节，以上两种情况虽然线程都为安全状态，但是synchronized锁定的数据范围却大不一样，性能上后者有着明显的优势。 用到了double checking使得synchronized锁定的数据范围进一步缩小，提高性能。 终止线程 线程的停止有两种可能，1、线程正常执行完毕，2、外部干涉–加入标识。加入标识后通过对标识的判断来控制线程的运行。 12345678910111213141516171819202122232425262728293031323334public class TeminateThread implements Runnable&#123; //加入标识，表示线程体是否运行 private boolean flag=true; private String name; public TeminateThread(String name) &#123; super(); this.name = name; &#125; @Override public void run() &#123; int i=0; //关联标识 while(flag) &#123; System.out.println(name+\"---\"+i++); &#125; &#125; //对外提供方法改变标识 public void terminate() &#123; this.flag=false; &#125; public static void main(String[] args) &#123; TeminateThread tt=new TeminateThread(\"lanous\"); new Thread(tt).start(); for(int i=0;i&lt;100;i++) &#123; if(i==88) &#123; tt.terminate();//线程的终止,通过改变标识终止线程 System.out.println(\"线程终止\"); &#125; System.out.println(\"m--\"+i); &#125; &#125;&#125; 线程的优先级 Java内使用1-10的整数表示线程的优先级，10最高、1最低。并且规定了三个常量NORM_PRIORITY(5)默认、MIN_PRIORITY(1)、MAX_PRIORITY(10)。 通过setPriority()方法设置线程的优先级。优先级高的线程不一定先执行，只表示一种概率，优先级高表示先执行的概率比较高。 1thread.setPriority(Thread.MAX_PRIORITY); 控制线程的方法： 1、join()：阻塞其他线程，让当前线程先执行。 2、yield()：礼让另一个线程，让其他线程先执行。 3、sleep()：使当前线程休眠（并不释放资源）一段时间后醒来继续执行。 其他 悲观锁与乐观锁 悲观锁：即上文中提到的synchronized关键字，锁住资源，直到当前线程访问结束，才可以使其他线程继续访问。 乐观锁：并不进行加锁。通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 CAS（比较并交换）的思想保证原子性。有三个值（旧的值，当前值，新的值），每次访问都将旧值与当前值进行比较，如果两者相等，则将新的值赋给旧值。 123456789101112131415161718192021public class CAS &#123; //库存 private static AtomicInteger stock=new AtomicInteger(5); public static void main(String[] args) &#123; for(int i =0;i&lt;5;i++) &#123; new Thread(()-&gt;&#123; try &#123; Thread.sleep(1200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Integer left=stock.decrementAndGet(); if(left&lt;1) &#123; System.out.println(\"抢完了\"); return; &#125; System.out.println(Thread.currentThread().getName()+\"抢了一件------还剩\"+left); &#125;).start(); &#125; &#125;&#125; Java中有如AtomicInteger类实现了此方法，保证了数据的原子性（不可再分），提供了一种比悲观锁性能更优的并发解决方案。 volatile关键字 用于保证数据的同步（也就是可见性），且只保证数据的同步，不保证原子性。 1234567891011121314private volatile static int num=0;public static void main(String[] args) &#123; new Thread(()-&gt;&#123; while(num==0) &#123;//死循环， &#125; &#125;).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num=1; System.out.println(num);&#125; 数据num被该关键字修饰时，一旦其发生变化，系统会立刻修改该值，哪怕之前存在未能结束的死循环时。 ThreadLocal ThreadLocal指每个线程自身的存储本地、局部区域。各个线程之间不会互相影响。 1234567891011121314151617181920212223242526 //设置初始值 private static ThreadLocal&lt;Integer&gt; threadLocal=new ThreadLocal&lt;&gt;() &#123; protected Integer initialValue() &#123; return 200; &#125; &#125;; public static void main(String[] args) &#123; //获取值 System.out.println(Thread.currentThread().getName()+\"--&gt;\"+threadLocal.get()); //设置值 threadLocal.set(99); System.out.println(Thread.currentThread().getName()+\"--&gt;\"+threadLocal.get()); new Thread(new MyRun()).start();//主线程不影响此线程的值 &#125; public static class MyRun implements Runnable&#123; @Override public void run() &#123; threadLocal.set(66); System.out.println(Thread.currentThread().getName()+\"--&gt;\"+threadLocal.get()); &#125; &#125; //输出结果为：main--&gt;200main--&gt;99Thread-0--&gt;66 Thread-0线程中的值的改变，并没有影响到主线程中的值。","categories":[],"tags":[]},{"title":"Java.IO（包含Commons-io的使用）","slug":"Java-IO（包含Commons-io的使用）","date":"2019-04-15T09:20:07.000Z","updated":"2019-04-15T14:43:06.857Z","comments":true,"path":"2019/04/15/Java-IO（包含Commons-io的使用）/","link":"","permalink":"http://yoursite.com/2019/04/15/Java-IO（包含Commons-io的使用）/","excerpt":"IO流相关知识输入字节流InputStream，输出字节流OutputStream，字符输入流Reader，字符输出流Writer等等，走进IO流的世界。","text":"IO流相关知识输入字节流InputStream，输出字节流OutputStream，字符输入流Reader，字符输出流Writer等等，走进IO流的世界。 File类1234567File src=new File(\"F:/JAVAproject/IO/src/zy/io/lanous1.png\");System.out.println(\"名称：\"+src.getName());System.out.println(\"路径：\"+src.getPath());System.out.println(\"绝对路径：\"+src.getAbsolutePath());System.out.println(\"父路径：\"+src.getParent());System.out.println(\"父对象：\"+src.getParentFile().getName()); 创建目录 mkdir()必须确保上级目录存在，mkdies()上次目录可以不存在，会一起创建 123456789101112131415File dir=new File(\"F:/JAVAproject/IO/dir/test\");//创建目录,mkdirs()dir.mkdirs();//列出下级名称String[] subNames=dir.list();for(String temp:subNames) &#123; System.out.println(temp);&#125;//列出下级对象File[] subFiles=dir.listFiles();for(File s:subFiles) &#123; System.out.println(s.getAbsolutePath());&#125; 流的操作 程序中可以分为四步：（一）创建源、（二）选择流、（三）操作、（四）释放流 1、字节输入流 1234567891011121314151617181920212223242526272829//创建源File src = new File(\"abc.txt\");//选择流InputStream is=null;try &#123; is=new FileInputStream(src); //操作（分段读取） byte[] flush=new byte[100];//缓冲容器 int len=-1;//接收长度 while((len=is.read(flush))!=-1) &#123; //字节数组--》字符串 String s=new String(flush,0,len); System.out.println(s); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; //释放资源 try &#123; if(null!=is) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 字节输出流 123456789101112131415161718192021222324//创建源File dest=new File(\"yuan.txt\");//选择流OutputStream os =null;try &#123; //操作（写出） os=new FileOutputStream(dest,false);//false为重写文件内容，true为文件尾部追加 String msg=\"let fire brun everything\"; byte[] datas=msg.getBytes();//编码 os.write(datas,0,datas.length); os.flush();&#125;catch(FileNotFoundException e)&#123; e.printStackTrace();&#125;catch(IOException e) &#123; e.printStackTrace();&#125;finally &#123; //释放资源 try &#123; if (null != os) &#123; os.close(); &#125; &#125; catch (Exception e) &#123; &#125;&#125; 2、字符输入流 123456789//操作char[] flush=new char[1024];int len=-1;while((len=r.read(flush))!=-1)&#123; //字符数组--》字符串 String s=new String(flush,0,len); System.out.println(s);&#125; 字符输出流 12345678//写法一String msg=\"never run away yuan\";wr.write(msg);wr.flush();//写法二wr.append(\"never run away\").append(\"yuan\");wr.flush(); 创建源、选择流、释放操作与字节输出流和字节输入流类似，修改类名即可。 3、字节数组输出流 ByteArrayOutputStream()内的close()为空方法，可有可无。 当子类需要使用新增方法时无法发生多态。 1234567891011121314151617181920//创建流byte[] dest=null;//选择流（新增方法）（无法使用多态）ByteArrayOutputStream baos=null;try &#123; baos=new ByteArrayOutputStream(); //操作 String msg=\"to be number one\"; byte[] datas=msg.getBytes();//字符串--》字节数组（编码） baos.write(datas, 0, datas.length); baos.flush(); //获取数据 dest=baos.toByteArray(); System.out.println(dest.length+\"--&gt;\"+new String(dest,0,baos.size()));&#125;catch(IOException e) &#123; e.printStackTrace();&#125;finally &#123; &#125; 字节数组输入流 123456789101112131415161718//创建流byte[] src=\"to be number one\".getBytes();//选择流InputStream is=null;try &#123; is=new ByteArrayInputStream(src); //操作 byte[] flush=new byte[5];//缓冲容器 int len=-1;//接收长度 while((len=is.read(flush))!=-1) &#123; String s=new String(flush,0,len); System.out.println(s); &#125;&#125;catch(IOException e) &#123; e.printStackTrace();&#125;finally &#123; &#125; 使用文件字节输入、输出流实现文件的拷贝。 即对文件先读取再写出。实现方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940//传入源地址和目标地址即可 public static void copy(String srcPath,String destPath) &#123; //创建源 File src=new File(srcPath); File dest=new File(destPath); //选择流 OutputStream os =null; InputStream is=null; try &#123; is=new FileInputStream(src); os=new FileOutputStream(dest); //操作（分段读取） byte[] flush=new byte[1024]; int len=-1; while((len=is.read(flush))!=-1) &#123; os.write(flush, 0, len); &#125; &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源，，分别关闭，先打开的后关闭 try &#123; if (null != os) &#123; os.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if (null != is) &#123; is.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4、字节输入缓冲流、字节输出缓冲流。字符输入缓冲流、字符输出缓冲流。 修改如下选择流的程序即可，缓冲流可以提升一定的程序性能。这也是一种装饰设计模式的应用。 12345is=new BufferedInputStream(new FileInputStream(src));os=new BufferedOutputStream(new FileOutputStream(dest));r= new BufferedReader(new FileReader(src));w=new BufferedWriter(new FileWriter(dest)); 5、转换流 在JDK1.7之后，释放流的操作可以简化为try with resources形式，在转换流中我们使用这种释放方式。 可以不用进行finally操作。 1234567891011121314//操作网络流,下载百度的源代码try(BufferedReader r=new BufferedReader(new InputStreamReader(new URL(\"http://www.baidu.com\").openStream(),\"UTF-8\")); BufferedWriter w=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"baidu.html\"),\"UTF-8\")))&#123; //操作 String temp; while((temp=r.readLine())!=null) &#123; //System.out.println(temp); w.write(temp); w.newLine(); &#125; w.flush();&#125;catch(IOException e) &#123; e.printStackTrace();&#125; 装饰设计模式浅谈需要拥有如下四个部分： 抽象组件：需要装饰的抽象对象（接口或抽象父类） 具体组件：需要装饰的对象 抽象装饰类：包含了对抽象组件的引用以及装饰着共有的方法 具体装饰类：被装饰的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class DecoreatTest02 &#123; public static void main(String[] args) &#123; Drink coffee=new Coffee(); Drink suger=new Suger(coffee);//装饰 System.out.println(suger.info()+\"---\"+suger.cost()); Drink milk=new Milk(coffee);//装饰 System.out.println(milk.info()+\"---\"+milk.cost()); Drink milkpuls=new Milk(suger);//装饰 System.out.println(milkpuls.info()+\"---\"+milkpuls.cost()); &#125;&#125;//抽象组件interface Drink&#123; double cost();//费用 String info();//说明&#125;//具体组件class Coffee implements Drink&#123; private String name=\"原味咖啡\"; @Override public double cost() &#123; return 10; &#125; @Override public String info() &#123; return name; &#125;&#125;//抽象装饰类abstract class Decorate implements Drink&#123; //对抽象组件的引用 private Drink drink; public Decorate(Drink drink) &#123; this.drink=drink; &#125; @Override public double cost() &#123; return this.drink.cost(); &#125; @Override public String info() &#123; return this.drink.info(); &#125;&#125;//具体装饰类class Milk extends Decorate&#123; public Milk(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()+7; &#125; @Override public String info() &#123; return super.info()+\"加入了牛奶\"; &#125;&#125;class Suger extends Decorate&#123; public Suger(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()+2; &#125; @Override public String info() &#123; return super.info()+\"加入了蔗糖\"; &#125;&#125;//输出如下原味咖啡加入了蔗糖---12.0原味咖啡加入了牛奶---17.0原味咖啡加入了蔗糖加入了牛奶---19.0 可以使用装饰类对具体的组件进行装饰使其完成其他方法，调用时方便。 Commons-io的使用阿帕奇网站上提供了十分方便的Commons-io，对java的IO流操作提供了便捷的API。以下列出其中常用的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//文件long len=FileUtils.sizeOf(new File(\"F:/JAVAproject/IO_zs/src/edu/nj/io/CopyTxt.java\"));System.out.println(len);//目录len = FileUtils.sizeOf(new File(\"F:\\\\JAVAproject\\\\IO\"));System.out.println(len);//非空第一层目录Collection&lt;File&gt; files=FileUtils.listFiles(new File(\"F:/JAVAproject/IO\"), EmptyFileFilter.NOT_EMPTY, null);for(File file:files) &#123; System.out.println(file);&#125;System.out.println(\"--------------------------\");//非空子目录files=FileUtils.listFiles(new File(\"F:/JAVAproject/IO\"), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE);for(File file:files) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println(\"--------------------------\");//非空且后缀名为javafiles=FileUtils.listFiles(new File(\"F:/JAVAproject/IO\"), FileFilterUtils.and(new SuffixFileFilter(\"java\"),EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE);for(File file:files) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println(\"--------------------------\");//后缀名为java或classfiles=FileUtils.listFiles(new File(\"F:/JAVAproject/IO\"), FileFilterUtils.or(new SuffixFileFilter(\"java\"),new SuffixFileFilter(\"class\")), DirectoryFileFilter.INSTANCE);for(File file:files) &#123; System.out.println(file.getAbsolutePath()); &#125;//读取文件String msg=FileUtils.readFileToString(new File(\"aaa.txt\"),\"UTF-8\");System.out.println(msg);byte[] datas=FileUtils.readFileToByteArray(new File(\"aaa.txt\"));System.out.println(datas.length);//逐行读取List&lt;String&gt; msgs=FileUtils.readLines(new File(\"aaa.txt\"),\"UTF-8\");for(String s:msgs) &#123; System.out.println(s);&#125;System.out.println(\"------------------\");LineIterator it=FileUtils.lineIterator(new File(\"aaa.txt\"),\"UTF-8\");while(it.hasNext()) &#123; System.out.println(it.nextLine());&#125;//写出文件FileUtils.write(new File(\"happy.txt\"), \"我是不朽的\\r\\n\",\"UTF-8\");FileUtils.writeStringToFile(new File(\"happy.txt\"), \"永不止步\\r\\n\",\"UTF-8\",true);FileUtils.writeByteArrayToFile(new File(\"happy.txt\"), \"永不放弃\\r\\n\".getBytes(\"UTF-8\"),true);//写出列表List&lt;String&gt; datas=new ArrayList&lt;String&gt;();datas.add(\"aaa\");datas.add(\"bbb\");datas.add(\"ccc\");FileUtils.writeLines(new File(\"happy.txt\"), datas,\"---\",true);//复制文件FileUtils.copyFile(new File(\"aaa.txt\"), new File(\"aaa.copy.txt\"));//复制文件到目录FileUtils.copyFileToDirectory(new File(\"aaa.txt\"), new File(\"lib\"));//目录到目录FileUtils.copyDirectoryToDirectory(new File(\"lib\"), new File(\"aaa\"));//复制目录FileUtils.copyDirectory(new File(\"lib\"), new File(\"aaa\"));//拷贝URLString u=\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1447299376,2290556778&amp;fm=27&amp;gp=0.jpg\";FileUtils.copyURLToFile(new URL(u), new File(\"bilbil.png\"));String datas=IOUtils.toString(new URL(\"http://www.baidu.com\"), \"UTF-8\");System.out.println(datas); 看上去代码太多，其实所有的方法都可以做到见名知意，十分方便的实现了文件的查找、读取、写出以及拷贝。","categories":[],"tags":[]},{"title":"Java集合类（容器)","slug":"Java集合类（容器)","date":"2019-04-14T13:35:48.000Z","updated":"2019-04-15T09:14:43.055Z","comments":true,"path":"2019/04/14/Java集合类（容器)/","link":"","permalink":"http://yoursite.com/2019/04/14/Java集合类（容器)/","excerpt":"Collections集合类集合存放在java.util包中，分为set(集）、list(列表）和map(映射)三类详细地分享了集合类的使用。","text":"Collections集合类集合存放在java.util包中，分为set(集）、list(列表）和map(映射)三类详细地分享了集合类的使用。 ListList中顺序与存放顺序一致且允许重复，主要实现类有ArrayList、LinkedList、Vector。 ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 List&lt;String&gt; c=new ArrayList&lt;&gt;(); System.out.println(c.size()); //返回当前大小 System.out.println(c.isEmpty()); //判断是否为空 c.add(\"aaa\"); //增加元素 c.add(\"bbb\"); System.out.println(c); System.out.println(c.size()); System.out.println(c.contains(\"aaa\")); //判断是否包含元素 Object obj=c.toArray(); //转换为一个Object对象 System.out.println(obj); c.remove(\"bbb\"); //移除元素 System.out.println(c); c.clear(); //清空元素 System.out.println(c.size()); List&lt;String&gt; list03=new ArrayList&lt;&gt;(); list03.add(\"A\"); list03.add(\"B\"); list03.add(\"C\"); list03.add(\"D\"); System.out.println(list03); list03.add(2,\"zy\"); //在指定索引位置处插入元素 System.out.println(list03); list03.remove(2); //移除指定索引处的元素 System.out.println(list03); list03.set(2, \"zy\"); //替换指定索引处的元素 System.out.println(list03);//输出结果如下： 0true[aaa, bbb]2true[Ljava.lang.Object;@3b192d32[aaa]0[A, B, C, D][A, B, zy, C, D][A, B, C, D][A, B, zy, D] ArrayList类似于数组，使用了顺序存储结构。 ArrayList由于使用顺序存储结构，所以当容量告急时需进行扩容，而ArrayList的扩容通过数组拷贝arraycopy实现。 如顺序存储结构一样，ArrayList在执行插入或删除操作时需要遍历该索引之后的所有元素，执行效率不高。 LinkedList LinkedList为链式存储结构，在使用时无需考虑空间问题，一个节点由前指针、数据域、后指针构成。 123Node previous; //上一个节点Node next; //下一个节点Object element; //数据元素 LinkedList在执行插入或删除操作时，只需要改变指针的指向，无需遍历整个集合。但是在查找时，需要从头指针开始进行遍历，因此查询效率低，插入或删除效率高。 Vector 与ArrayList相比提供了一个线程安全的集合，但是在效率上有了牺牲，大部分方法与其类似。 MapMap用于存放键值对（key–value）,其中key不可重复，value可以存放Object类的任意对象。主要实现类有HashMap、TreeMap。 HashMap HashMap线程不安全，效率高，允许key或value为null，HashTable线程安全，效率低，不允许key或value为null。 12345678910111213141516171819202122232425262728293031323334Map&lt;Integer,String&gt; m1=new HashMap&lt;&gt;();m1.put(1, \"one\"); //存放键值对m1.put(2, \"two\");m1.put(3, \"three\");System.out.println(m1.get(1)); //获得指定key对应的值System.out.println(m1.size()); //获取集合的大小System.out.println(m1.isEmpty()); //判断是否为空System.out.println(m1.containsKey(2)); //是否包含指定键System.out.println(m1.containsValue(\"four\")); //是否包含指定值Map&lt;Integer,String&gt; m2=new HashMap&lt;&gt;();m2.put(4, \"四\");m2.put(5, \"五\");m1.putAll(m2);System.out.println(m1);//键值Key不能重复，如有重复，新的会将老的覆盖m1.put(3, \"三\");System.out.println(m1);//value可以存放自定义类Employee e1=new Employee(1001,\"张三\",50000);Employee e2=new Employee(1002,\"李四\",10000);Employee e3=new Employee(1003,\"王五\",8000);Employee e4=new Employee(1004,\"小七\",6000);Employee e5=new Employee(1001,\"小六\",6000);Map&lt;Integer,Employee&gt; map=new HashMap&lt;&gt;();map.put(1001, e1);map.put(1002, e2);map.put(1003, e3);map.put(1004, e4);map.put(1001, e5);Employee emp=map.get(1001); HashMap中的结点格式如下： 1234int hash; //用于存放Hash值K key; //存放键V value; //存放值Node next; //下一个结点的指针 hash值是通过key对象的hashcode()经特定算法（如：与bucket array的长度按位与）计算出来的。等于在bucket array的每一个元素位置存入一个链表。 所以HashMap输出的对象顺序与存入时是不同的。 TreeMap TreeMap与HashMap最大的区别就是有无顺序，TreeMap中存放时会对对象进行排序。 此时可以通过实现Comparable接口是对象可以通过自比较进行我们想要的排序，只要重写compareTo()方法即可。 SetSet中没有顺序且不允许重复，实现类主要有HashSet、TreeSet HashSet底层通过HashMap实现，存入HashSet的值等于HashMap中的key值，所以其中的值没有顺序且不允许重复。 HashSet与TreeSet的区别类似于TreeMap与HashMap的区别。 Collections辅助类Collection是接口，Collections是工具类 123456789101112131415List&lt;String&gt; list =new ArrayList&lt;&gt;();for(int i=0;i&lt;10;i++) &#123; list.add(\"lanous\"+i);&#125;System.out.println(list);Collections.shuffle(list); //随机排列list中的元素System.out.println(list);Collections.reverse(list); //倒序排列System.out.println(list);Collections.sort(list); //按照递增顺序排序，自定义的类使用Comparable接口System.out.println(list);System.out.println(Collections.binarySearch(list, \"lanous3\"));//二分法查找 Iterator迭代器的使用（遍历容器内的元素） List 12345678910111213List&lt;String&gt; list=new ArrayList&lt;&gt;();list.add(\"aa\");list.add(\"bb\");list.add(\"cc\");//使用Iterator遍历Listfor(Iterator&lt;String&gt; iter=list.iterator();iter.hasNext();) &#123; String temp=iter.next(); System.out.println(temp);&#125;System.out.println();for(Object temp:list) &#123; System.out.println(temp);&#125; 增强for循环输出与迭代器遍历输出比较，结果一样。 Map 123456789101112131415161718192021Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();map.put(1, \"a\");map.put(2, \"b\");map.put(3, \"c\");//使用Iterator遍历Map（一）Set&lt;Entry&lt;Integer,String&gt;&gt; ss =map.entrySet();for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter=ss.iterator();iter.hasNext();) &#123; Entry&lt;Integer,String&gt; temp=iter.next(); System.out.println(temp.getKey()+\"---\"+temp.getValue());&#125;System.out.println();//遍历Map（二）Set&lt;Integer&gt; keySet=map.keySet();for(Iterator&lt;Integer&gt; iter=keySet.iterator();iter.hasNext();) &#123; Integer key=iter.next(); System.out.println(key+\"---\"+map.get(key));&#125; 遍历Map有两种方式： （一）通过Map.entrySet每一次遍历返回一个key/value键值对的对象，可以一次遍历Map中的元素。 （二）通过Map.keySet遍历key对象，然后通过key进行取值。此方法相较于前者更加灵活，可以根据需要取得指定key相对应的值。 Map.entrySet迭代器会生成EntryIterator,其返回的实例是一个包含key/value键值对的对象。而keySet中迭代器返回的只是key对象，还需要到map中二次取值。 Set 12345678910Set&lt;String&gt; set=new HashSet&lt;&gt;();set.add(\"aa\");set.add(\"bb\");set.add(\"cc\");//使用Iterator遍历Setfor(Iterator&lt;String&gt; iter=set.iterator();iter.hasNext();) &#123; String temp=iter.next(); System.out.println(temp);&#125; 使用方法与List相差无几。","categories":[],"tags":[]},{"title":"Java知识点总结（三）","slug":"Java知识点总结（三）","date":"2019-04-05T13:47:52.000Z","updated":"2019-04-15T09:14:18.469Z","comments":true,"path":"2019/04/05/Java知识点总结（三）/","link":"","permalink":"http://yoursite.com/2019/04/05/Java知识点总结（三）/","excerpt":"Java知识点总结（三）","text":"Java知识点总结（三） 时间对象和字符串之间的互相转换 把时间对象按照指定格式转换成相应的字符串 123DateFormat df=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");String str=df.format(new Date(4000000));System.out.println(str); 此时输出就是按照自己用“y,M,d,h,s”等字母所指定的时间格式 把字符串按照相应的格式转成相应的时间对象 123DateFormat df2=new SimpleDateFormat(\"yyyy年MM月dd日 hh时mm分ss秒\");Date date=df2.parse(\"1983年06月03日 21时34分33秒\");System.out.println(date); 此时输出结果为Fri Jun 03 21:34:33 GMT+08:00 1983，通过parse()方法可以按指定格式将输入的字符串解析为时间对象。 随机数Random类1234567891011121314151617181920212223242526public class TestRandom &#123; public static void main(String[] args) &#123; Random rand=new Random(); //随机生成[0,1)之间的double类型的数据 System.out.println(rand.nextDouble()); //随机生成int类型允许范围之内的整形数据 System.out.println(rand.nextInt()); //随机生成[0,1)之间的float类型的数据 System.out.println(rand.nextFloat()); //随机生成false或者true System.out.println(rand.nextBoolean()); //随机生成[0,10)之间的int类型的数据 System.out.println(rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据 System.out.println(20+rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂） System.out.println(20+(int)(rand.nextDouble()*10)); &#125;&#125; 可变字符序列StringBuilder123456789101112131415161718192021public class TestStringBuilder2 &#123; public static void main(String[] args) &#123; StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;26;i++) &#123; sb.append((char)('a'+i)); &#125; System.out.println(sb); sb.reverse();//倒序 System.out.println(sb); sb.setCharAt(3, '啦'); System.out.println(sb); sb.insert(0, '哦').insert(6,'嗯').insert(10, '啊');//链式调用。核心就是该方法调用了return this,把自己返回 System.out.println(sb); sb.delete(20,23); System.out.println(sb); &#125;&#125; append()方法可以在其中添加元素。reverse()方法实现倒叙功能。setCharAt()可以设置指定位置的元素。insert()方法可以通过链式调用实现连续插入。delete()用法类似于insert()。","categories":[],"tags":[]},{"title":"Java知识点总结（二）","slug":"Java知识点总结（二）","date":"2019-04-04T13:29:18.000Z","updated":"2019-04-15T09:14:38.833Z","comments":true,"path":"2019/04/04/Java知识点总结（二）/","link":"","permalink":"http://yoursite.com/2019/04/04/Java知识点总结（二）/","excerpt":"Java知识点总结（二）","text":"Java知识点总结（二） 数组拷贝 System类提供了arraycopy()方法实现数组的拷贝，JDK1.8中源码如下： 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 其中src为拷贝源数组，srcPos为源数组中要拷贝的第一个数据的索引下标，dest为目标数组，destPos为目标数组中拷贝的第一个位置下标，length为拷贝的长度。 arraycopy()可以实现删除数组中指定索引位置的元素，具体实现如下： 1234567public static String[] removeEle(String[] s,int index) &#123; System.arraycopy(s,index+1, s, index, s.length-index-1); s[s.length-1]=null; return s;&#125; 实际上就是数组的自我拷贝，将要删除的后面一位元素开始所有元素往前拷贝一格，就可以覆盖掉要删除的元素，然后将null赋值给数组的最后一个位置。 arraycopy()还可以实现数组的扩容。当一个数组空间不足时，可以通过数组扩容来实现加大空间，实现如下： 1234567public static String[] extendRange(String[] s1) &#123; String[] s2=new String[s1.length+10]; System.arraycopy(s1,0,s2,0,s1.length);//将S1中所有的元素拷贝到了S2 return s2; &#125; 实际就是定义一个更大的数组，然后将原数组的所有值从索引0位置开始拷贝到新数组中，然后返回新的数组，从而实现数组的扩容。 数组工具类的使用1234567891011121314public class TestArrays &#123; public static void main(String[] args) &#123; int[] a= &#123;11,33,226,77,44,276,20&#125;; System.out.println(a); System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//排序 System.out.println(Arrays.toString(a)); System.out.println(Arrays.binarySearch(a, 77));//查找指定元素 System.out.println(Arrays.binarySearch(a, -77)); &#125;&#125; 定义数组时，赋值给a 的实际是一个地址指针，当直接打印a时，输出的时一个地址。想要输出数组中的每个元素，需要使用Array类提供的toString()方法，源码如下： 12345678910111213141516public static String toString(int[] a) &#123; if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); &#125;&#125; 通过StringBuilder类中的append()方法循坏添加所有元素，然后返回。 sort()方法实现升序排序。 binarySearch方法查找并返回指定的元素，当元素不存在时，返回-1。 通过二维数组实现存储表格数据12345678Object[] emp1= &#123;1001,\"张三\",23,\"学生\",\"1995-12-27\"&#125;;Object[] emp2= &#123;1002,\"李四\",24,\"学2生\",\"1993-10-17\"&#125;;Object[] emp3= &#123;1003,\"王五\",25,\"学3生\",\"1994-10-07\"&#125;;Object[][] tableData= new Object[3][];tableData[0]=emp1;tableData[1]=emp2;tableData[2]=emp3; 冒泡排序算法12345678910111213141516171819202122232425262728public class TestBubbleSort &#123; public static void main(String[] args) &#123; int temp; int[] a= &#123;2873,23,54,24,9838,563,30487,2653&#125;; for(int i=0;i&lt;a.length-1;i++) &#123; boolean flag=true; for(int j=0;j&lt;a.length-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; flag=false; &#125; System.out.println(Arrays.toString(a)); &#125; if(flag) &#123; System.out.println(\"循环结束\"); break; &#125; System.out.println(\"###################\"); &#125; &#125;&#125; 加入一个布尔类型的变量，当一整行数据全部循环一次但没有发生交换时，说明排序已经结束，就跳出循环，不再进行之后无用的循环，提高了循环效率。 二分法查找算法123456789101112131415161718public static int BinarySearch(int[] arr,int value) &#123; //二分法查找 int low=0; int high=arr.length-1; while(low&lt;=high) &#123; int mid = (low+high)/2; if(value==arr[mid]) &#123; return mid; &#125; if(value&gt;arr[mid]) &#123; low=mid+1; &#125; if(value&lt;arr[mid]) &#123; high=mid-1; &#125; &#125; return -1;&#125; 使用二分法查找必须确保数组已经排好顺序。 当一个顺序数组输入时，每次从中间开始进行比较并舍弃掉数组不在的那一半，再次重复，直到查到结果为止。","categories":[],"tags":[]},{"title":"Java知识点总结（一）","slug":"Java知识点总结（一）","date":"2019-03-31T14:14:59.000Z","updated":"2019-04-15T09:14:10.651Z","comments":true,"path":"2019/03/31/Java知识点总结（一）/","link":"","permalink":"http://yoursite.com/2019/03/31/Java知识点总结（一）/","excerpt":"Java知识点总结（一）","text":"Java知识点总结（一） abstract抽象类 抽象类为子类提供统一的、规范的模板,子类必须实现相关的抽象方法。 123456public abstract class Animal &#123; //没有实现。子类必须实现 abstract public void shout(); &#125; 如上抽象类中的抽象方法没有实现，继承自此抽象类的子类必须实现shout()方法，如下给出的语句块，若不实现会编译报错。 123456789class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println(\"汪汪汪\"); &#125; &#125; 接口及其实现类 接口使用interface关键字定义，接口中只能定义常量且接口中的方法皆为抽象方法。接口的实现通过implements关键字实现。如下的MyClass类中必须实现test01()方法，并且可以在方法中直接使用MAX_AGE常量。 123456789101112131415161718public interface TestInterface &#123; int MAX_AGE=100;//接口中只能定义常量 void test01();//方法只能抽象&#125;class MyClass implements TestIterface&#123; @Override public void test01() &#123; System.out.println(\"llll\"); System.out.println(MAX_AGE); &#125; &#125; 接口可以多继承而普通类无法继承多个类 12345678910111213141516171819202122232425interface A&#123; void test1();&#125;interface B&#123; void test2();&#125;//接口可以多继承，接口C继承接口A和Binterface C extends A,B&#123; void test3();&#125;class T implements C &#123; @Override public void test1() &#123; &#125; @Override public void test2() &#123; &#125; @Override public void test3() &#123; &#125;&#125; String字符串类及基本用法 String初始化有两种方法，“+”可以作为字符串连接符使用 1234567891011121314String str=\"asd\";String str2=new String(\"asd\");String str3=\"abc\"+\"sjdh\";String str4=\"18\"+19;//当加法一边是字符串类型时，加法作为字符串连接符，输出“1819”System.out.println(str4);System.out.println(\"###########\");String str10=\"zy\";String str11=\"zy\";String str12=new String(\"zy\");System.out.println(str10==str11);System.out.println(str11==str12); //str11和str12不是同一个对象 如上语句块中str11和str12虽然定义了相同的字符串，但是str11==str12的运算结果却是false，因为两种方法底层实现不同，进行==运算时比较的是不同的内存地址。 所以通常比较字符串时，使用equals 1System.out.println(str12.equals(str11));//此时的输出是true，比较的是一个个字符 以下提供了String类的一些常用方法： 123456789101112131415161718192021222324252627282930313233343536373839String s1=\"core Java\";String s2=\"Core Java\";System.out.println(s1.charAt(3));//提取下标为3处的字符System.out.println(s2.length());//返回字符串长度System.out.println(s1.equals(s2));//比较两个字符串是否相等System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串是否相等（忽略大小写）System.out.println(s1.indexOf(\"Java\"));//s1中是否包含Java,返回Java的第一个位置下标System.out.println(s1.indexOf(\"apple\"));//s1中是否包含apple,不包含时返回-1String s=s1.replace(' ','&amp;');//将s1中的空格替换成&amp;，s1本身没变System.out.println(\"result is:\"+s);String ss=\"\";String ss1=\"How are you?\";System.out.println(ss1.startsWith(\"How\"));//判断是否以How开头System.out.println(ss1.endsWith(\"you\"));//判断是否以you结尾ss=ss1.substring(4);//提取子字符串：从下标为4的开始到字符串结尾结束System.out.println(ss);ss=ss1.substring(4, 7);//提取字符串：下标[4，7）System.out.println(ss);ss=ss1.toLowerCase();//转小写System.out.println(ss);ss=ss1.toUpperCase();//转大写System.out.println(ss);String ss2=\" How old are you? \";ss=ss2.trim();//去除字符串首位的空格，中间的不去除System.out.println(ss);System.out.println(ss2);","categories":[],"tags":[]},{"title":"飞机小游戏总结","slug":"飞机小游戏总结","date":"2019-03-28T05:05:54.000Z","updated":"2019-04-15T09:13:32.670Z","comments":true,"path":"2019/03/28/飞机小游戏总结/","link":"","permalink":"http://yoursite.com/2019/03/28/飞机小游戏总结/","excerpt":"小飞机游戏使用最基础知识编写，上传仅用于学习交流（复习知识）","text":"小飞机游戏使用最基础知识编写，上传仅用于学习交流（复习知识） 实现效果如下： 新游戏： 游戏结束： 详细代码见GitHub 重要知识点 创建getImage方法用于输入路径以返回图片对象,其中所使用的IO流知识有待进一步学习。 1234567891011 //GameUtil类的公共方法实现所有图片的读取public static Image getImage(String path) &#123; BufferedImage bi=null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; return bi;&#125; 重写键盘监听的内部类方法对按键的按下和松开监听实现对飞机的控制 1234567891011121314//键盘监听的内部类class KeyMonitor extends KeyAdapter&#123; @Override public void keyPressed(KeyEvent e) &#123; super.keyPressed(e); p.addDirection(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; super.keyReleased(e); p.minusDirection(e); &#125; 实现此类需导入如下Java包 123import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent; 重写方法实现窗口的更新 1234567891011121314151617class PaintThread extends Thread&#123; @Override public void run() &#123; super.run(); while(true) &#123; repaint();//重画 try &#123; Thread.sleep(40);//1s画25次 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后记 个人选了几个觉得感触最深的片段，详细代码点在里。 仅作为Java初学者的见解,小项目为本人参照教程手打。 一个在Java路上越走越远的咸鱼","categories":[],"tags":[]},{"title":"测试第一篇博客文章","slug":"测试第一篇博客文章","date":"2019-03-15T08:45:00.000Z","updated":"2019-03-15T14:27:04.005Z","comments":true,"path":"2019/03/15/测试第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/03/15/测试第一篇博客文章/","excerpt":"","text":"第一章内容 第二章内容 参考文献啦啦啦啦啦","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T08:41:06.794Z","updated":"2019-03-15T08:41:06.794Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}